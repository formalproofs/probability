--Please add to main pretty pretty please
import Mathlib.Data.Nat.Basic
import Mathlib.Data.Real.Basic
import Mathlib.Data.Rat.Defs
import Mathlib.Data.NNReal.Basic

import Mathlib.Logic.Function.Defs

import Mathlib.Data.Set.Basic

import Mathlib.Data.Finset.Defs
import Mathlib.Data.Finset.Image

import Mathlib.Algebra.Group.Pi.Basic -- for Pi.single

--import Mathlib.Tactic.Explode

open NNReal

variable {œÑ : Type}

section Indicator

/-- Boolean indicator function -/
def indicator (cond : Bool) : ‚Ñö := cond.rec 0 1

abbrev ùïÄ : Bool ‚Üí ‚Ñö := indicator

/-- Indicator is 0 or 1 -/
theorem ind_zero_one (cond : œÑ ‚Üí Bool) : ( (ùïÄ‚àòcond) œâ = 1)‚à®((ùïÄ‚àòcond) œâ = 0) := by
    by_cases h : cond œâ
    ¬∑ left; simp only [Function.comp_apply, h, indicator]
    ¬∑ right; simp only [Function.comp_apply, h, indicator]

end Indicator

---------- Probability Definitions  -----------------------------------------

/-- states that p is a valid probability value -/
@[simp]
abbrev Prob (p : ‚Ñö) : Prop := 0 ‚â§ p ‚àß p ‚â§ 1

namespace Prob

variable {p x y : ‚Ñö}

@[simp]
theorem of_complement ( hp : Prob p) : Prob (1-p) := by
        simp_all only [ Prob, sub_nonneg, tsub_le_iff_right, le_add_iff_nonneg_right, and_self]

@[simp]
theorem complement_inv_nneg (hp : Prob p) : 0 ‚â§ (1-p)‚Åª¬π := by simp_all only [Prob, inv_nonneg, sub_nonneg]

theorem lower_bound_fst (hp : Prob p) (h : x ‚â§ y) : x ‚â§ p * x + (1-p) * y := by
        have h2 : (1-p) * x ‚â§ (1-p) * y := mul_le_mul_of_nonneg_left h hp.of_complement.1
        linarith

theorem lower_bound_snd (hp : Prob p) (h : y ‚â§ x) : y ‚â§ p * x + (1-p) * y := by
        have h2 : p * y ‚â§ p * x := mul_le_mul_of_nonneg_left h hp.1
        linarith

theorem upper_bound_fst (hp : Prob p) (h : y ‚â§ x) : p * x + (1-p) * y ‚â§ x := by
        have h2 : (1-p) * y ‚â§ (1-p) * x := mul_le_mul_of_nonneg_left h hp.of_complement.1
        linarith

theorem upper_bound_snd (hp : Prob p) (h : x ‚â§ y) : p * x + (1-p) * y ‚â§ y := by
        have h2 : p * x ‚â§ p * y := mul_le_mul_of_nonneg_left h hp.1
        linarith

end Prob


---------- List Basic Properties Definitions  -----------------------------------------

section List
namespace List

variable {L : List ‚Ñö}

def scale (L : List ‚Ñö) (c : ‚Ñö) : List ‚Ñö := (L.map fun x‚Ü¶x*c)

-- TODO: find the theorem in mathlib that does this
theorem nonempty_length_gt_one (h : ¬¨L.isEmpty) : L.length ‚â• 1 :=
    by simp_all
       cases L
       ¬∑ contradiction
       ¬∑ exact tsub_add_cancel_iff_le.mp rfl


@[simp]
theorem scale_sum : (L.scale c).sum = c * L.sum :=
  by induction L
     ¬∑ simp [scale]
     ¬∑ simp_all [scale]
       ring

@[simp]
theorem scale_length : (L.scale c).length = L.length := by simp [scale]

theorem scale_nneg_of_nneg (h : ‚àÄl ‚àà L, 0 ‚â§ l) (h1 : 0 ‚â§ c) : (‚àÄl ‚àà L.scale c, 0 ‚â§ l) :=
  by induction L
     ¬∑ simp [List.scale]
     ¬∑ simp_all [List.scale]
       exact Left.mul_nonneg h.1 h1

theorem append_nneg_of_nneg (h : ‚àÄl ‚àà L, 0 ‚â§ l) (h1 : 0 ‚â§ p) : (‚àÄl ‚àà p::L, 0 ‚â§ l) :=
  by aesop

/-- adds a new probability to a list and renormalizes the rest --/
def grow (L : List ‚Ñö) (p : ‚Ñö) : List ‚Ñö := p :: (L.scale (1-p))

theorem grow_sum : (L.grow p).sum = L.sum * (1-p) + p :=
  by induction L
     ¬∑ simp [List.grow, List.scale]
     ¬∑ simp [List.grow, List.scale_sum]
       ring


/-- Removes head and rescales -/
def shrink : List ‚Ñö ‚Üí List ‚Ñö
    | nil => nil
    | head :: tail => tail.scale (1-head)‚Åª¬π


@[simp]
theorem shrink_length : L.shrink.length = L.tail.length :=
  by cases L; simp [List.shrink]; simp[List.shrink, List.scale]

theorem shrink_length_less_one : L.shrink.length = L.length - 1 :=
    by simp only [shrink_length, length_tail]


@[simp]
theorem shrink_sum (npt: L ‚â† []) (h : L.head npt < 1) :
        (L.shrink).sum = (L.tail).sum / (1 - L.head npt)  :=
        by cases L; contradiction; simp_all [List.shrink, List.scale_sum]; ring

theorem shrink_ge0 (h1 : ‚àÄl ‚àà L, Prob l) : ‚àÄl ‚àà (L.shrink), 0 ‚â§ l :=
    by simp [List.shrink]
       cases L with
       | nil => simp_all only [List.not_mem_nil, IsEmpty.forall_iff, implies_true]
       | cons head tail =>
           simp_all only [List.mem_cons, Prob, forall_eq_or_imp]
           have hh : 0 ‚â§ (1-head)‚Åª¬π := Prob.complement_inv_nneg h1.1
           exact List.scale_nneg_of_nneg (L:=tail) (c:=(1-head)‚Åª¬π) (fun l a ‚Ü¶ (h1.2 l a).1) hh

end List
end List

---------- LSimplex Definitions  -----------------------------------------

section LSimplex

variable {p : ‚Ñö}

/-- Self-normalizing list of probabilities  --/
structure LSimplex (L : List ‚Ñö) : Prop where
  nneg : ‚àÄp ‚àà L, 0 ‚â§ p               -- separate for convenience
  normalized : L.sum = 1             -- sums to 1

namespace LSimplex

def singleton : LSimplex [1] :=
  ‚ü®fun p a => by simp_all only [List.mem_cons, List.not_mem_nil, or_false, zero_le_one],
    List.sum_singleton‚ü©

variable {L : List ‚Ñö}  {c : ‚Ñö}
variable (S : LSimplex L)

/-- cannot define a simplex on an empty set -/
@[simp]
theorem nonempty (S : LSimplex L) : L ‚â† [] :=
        fun a => by have := S.normalized; simp_all

@[simp]
abbrev npt : LSimplex L ‚Üí L ‚â† [] := LSimplex.nonempty

def phead (h : LSimplex L) : ‚Ñö := L.head h.nonempty

/-- all probability in the head element -/
def degenerate (S : LSimplex L) : Bool := S.phead  == 1

@[reducible]
def supported  : Bool := ¬¨S.degenerate

@[simp]
theorem mem_prob (S : LSimplex L) : ‚àÄ p ‚àà L, Prob p :=
  fun p a => ‚ü® S.nneg p a,
               S.normalized ‚ñ∏ List.single_le_sum S.nneg p a‚ü©

theorem phead_inpr  : S.phead ‚àà L := List.head_mem S.nonempty

@[simp]
theorem phead_prob  : Prob S.phead := S.mem_prob S.phead S.phead_inpr

theorem phead_supp  (supp : S.supported) : S.phead  < 1 :=
  by simp [degenerate] at supp
     exact lt_of_le_of_ne S.phead_prob.2 supp

theorem supported_head_lt_one  (supp : S.supported) : L.head S.npt < 1 :=
    by have prob := LSimplex.mem_prob S (L.head S.npt) (List.head_mem (LSimplex.npt S))
       simp [LSimplex.degenerate] at supp
       simp [Prob] at prob
       exact lt_of_le_of_ne prob.2 supp

@[simp]
theorem List.grow_ge0 (h1 : ‚àÄl ‚àà L, 0 ‚â§ l) (h2 : Prob p) :  ‚àÄ l ‚àà (L.grow p), 0 ‚â§ l :=
    by simp [List.grow]
       constructor
       ¬∑ exact h2.1
       ¬∑ intro l a
         exact List.scale_nneg_of_nneg
               (L := L) (c := (1-p)) h1 (Prob.of_complement h2).1 l a

-- grows the simplex to also incude the probability p
@[simp]
theorem grow (S : LSimplex L) {p : ‚Ñö} (prob : Prob p) : LSimplex (L.grow p) :=
  {nneg := List.grow_ge0 S.nneg prob,
   normalized := by simp [List.grow_sum, S.normalized]}

lemma false_of_p_comp1_zero_p_less_one (h1 : 1 - p = 0) (h2 : p < 1) : False := by linarith

@[simp]
theorem tail_sum (S : LSimplex L) : L.tail.sum = (1 - L.head S.npt) :=
  by cases L; have := S.npt; contradiction; have := S.normalized; simp at this ‚ä¢; linarith

theorem degenerate_tail_zero (degen : S.degenerate) : ‚àÄ p ‚àà L.tail, p = 0 :=
  by simp [LSimplex.degenerate, LSimplex.phead] at degen
     have ts := S.tail_sum
     rw [degen] at ts; simp at ts
     have nneg := fun p a ‚Ü¶ S.nneg p (List.mem_of_mem_tail a)
     have lez := fun p a ‚Ü¶ List.single_le_sum nneg p a
     rw [ts] at lez
     intro p a
     have hl := nneg p a
     have hu := lez p a
     linarith


theorem shrink (S : LSimplex L) (supp : S.supported) : LSimplex (L.shrink) :=
  {nneg := List.shrink_ge0 (LSimplex.mem_prob S),
   normalized :=
     by have npt := S.npt
        have hh := LSimplex.supported_head_lt_one S supp
        have hh1 := S.tail_sum
        have hh2 : (1 - L.head npt) ‚â† 0 := by linarith
        rw[List.shrink_sum S.npt hh]
        exact (div_eq_one_iff_eq hh2).mpr hh1}

theorem grow_of_shrink_list (supp : S.supported) : L = (L.shrink).grow (S.phead) :=
   by induction L with
      | nil => have := S.nonempty; contradiction
      | cons head tail =>
             let h : (1-head) ‚â† 0 :=
               fun a => false_of_p_comp1_zero_p_less_one a (S.phead_supp supp)
             simp_all [List.grow, List.shrink, List.scale, LSimplex.phead]

-- all props of the same type are equal
theorem grow_of_shrink (supp : S.supported) :
        S = (S.grow_of_shrink_list supp) ‚ñ∏ (S.shrink supp).grow S.phead_prob := rfl

end LSimplex
end LSimplex

---------------- FinDist ----------------------------------------------------


/-- Finite probability distribution on a set-like list (non-duplicates) -/
structure Findist (N : ‚Ñï)  : Type where
  ‚Ñô : List ‚Ñö                      -- probabilities
  simplex : LSimplex ‚Ñô            -- proof of a measure
  lmatch : ‚Ñô.length = N           -- correct length of probability

namespace Findist

abbrev Delta : ‚Ñï ‚Üí Type := Findist
abbrev Œî : ‚Ñï ‚Üí Type := Delta

variable {N : ‚Ñï} (F : Findist N)

abbrev degenerate : Bool := F.simplex.degenerate
abbrev supported : Bool := F.simplex.supported

theorem supp_not_degen (supp : F.supported) : ¬¨ F.degenerate :=
        by simp_all [supported, degenerate]

@[simp]
theorem nonempty (F : Findist N) : N ‚â• 1 :=
  F.lmatch ‚ñ∏ List.length_pos_iff.mpr F.simplex.npt

@[simp]
theorem nonempty_P : F.‚Ñô ‚â† [] :=
  by have := F.simplex.npt
     intro a; contradiction


/-- add a new head -/
def grow {p : ‚Ñö} (prob : Prob p) : Findist (N + 1)  :=
    {‚Ñô       := F.‚Ñô.grow p,
     simplex := F.simplex.grow prob,
     lmatch  := by simp [List.grow, List.scale_length, F.lmatch]}

/-- if nondegenenrate then construct a tail distribution -/
def shrink  (supp : F.supported) : Findist (N - 1)  :=
    -- see: https://lean-lang.org/theorem_proving_in_lean4/The-Conversion-Tactic-Mode/
    let hh :  F.‚Ñô.shrink.length = N - 1 :=
      calc
        F.‚Ñô.shrink.length = F.‚Ñô.length - 1 := List.shrink_length_less_one
        _ = N - 1 := by conv => lhs; rw [F.lmatch]
    {‚Ñô := F.‚Ñô.shrink
     simplex := F.simplex.shrink supp
     lmatch := hh} --List.shrink_length_less_one (Findist.nonempty_P F)}


def singleton : Findist 1 :=
    {‚Ñô := [1]
     simplex := LSimplex.singleton,
     lmatch := by simp_all only [List.length_cons, List.length_nil, zero_add]}


abbrev phead := F.simplex.phead

--example (a : Prop) (b : Prop) : ¬¨(a ‚àß b) = (¬¨ a) ‚à® (¬¨b) :=

@[simp]
theorem phead_inpr : F.phead ‚àà F.‚Ñô := List.head_mem F.nonempty_P

@[simp]
theorem phead_prob : Prob F.phead := F.simplex.mem_prob F.phead F.phead_inpr

theorem nondegenerate_head (supp : F.supported) : F.phead < 1 :=
  by have h1 := Findist.phead_prob F
     simp_all only [supported, LSimplex.supported, LSimplex.degenerate,
                    LSimplex.phead, beq_iff_eq, phead, gt_iff_lt]
     simp! only [decide_not, Bool.not_eq_eq_eq_not, not, decide_eq_false_iff_not] at supp
     simp [Prob] at h1
     exact lt_of_le_of_ne h1.2 supp


-- For the use of ‚ñ∏ see: https://proofassistants.stackexchange.com/questions/1380/how-do-i-convince-the-lean-4-type-checker-that-addition-is-commutative

theorem grow_shrink_type (_ : F.supported) : Findist (N - 1 + 1) = Findist N :=
        (Nat.sub_add_cancel F.nonempty) ‚ñ∏ rfl

def growshrink (supp : F.supported) : Findist (N-1+1) :=
   (F.shrink supp).grow F.phead_prob

-- TODO: can we incorporate this example in the theorem below?
example (supp : F.supported) : ((F.shrink supp).grow F.phead_prob).‚Ñô = F.‚Ñô :=
    by have h1 : F.supported := by simp_all only
       simp [Findist.shrink, Findist.grow, Findist.phead]
       rw [‚ÜêLSimplex.grow_of_shrink_list F.simplex h1]


theorem grow_of_shrink_2 (supp : F.supported) :
  F.growshrink supp = ((F.grow_shrink_type supp).mpr F) :=
    by have h1 : F.supported := by simp_all only
       simp [Findist.growshrink, Findist.shrink, Findist.grow, Findist.phead]
       rw [Findist.mk.injEq]
       rw [‚ÜêLSimplex.grow_of_shrink_list F.simplex h1]
       congr; --TODO: here to deal with casts; need to understand them better (see example below)
         symm; exact Nat.sub_add_cancel F.nonempty;
         simp_all only [heq_cast_iff_heq, heq_eq_eq]

end Findist



/-- Finite probability space. See Finsample for the definition of the sample space. -/
structure Finprob : Type where
  ‚Ñô : List ‚Ñö
  prob : LSimplex ‚Ñô


lemma List.unique_head_notin_tail (L : List œÑ) (ne : L ‚â† []) (nodup : L.Nodup) :
      L.head ne ‚àâ L.tail :=
  by induction L
     ¬∑ simp at ne
     ¬∑ simp [List.head, List.tail]
       simp_all only [ne_eq, reduceCtorEq, not_false_eq_true, List.nodup_cons]

namespace Finprob

variable (P : Finprob)

@[simp]
def length := P.‚Ñô.length


def singleton : Finprob :=
   ‚ü® [1], LSimplex.singleton ‚ü©

def grow {p : ‚Ñö} (prob : Prob p) : Finprob :=
  ‚ü®P.‚Ñô.grow p, P.prob.grow prob‚ü©

/-- all probability in the head -/
abbrev degenerate  : Bool := P.prob.degenerate
abbrev supported  : Bool := P.prob.supported

theorem not_degen_supp (supp : ¬¨P.degenerate) : P.supported :=
  by simp_all [Finprob.degenerate, Finprob.supported]

theorem degen_of_not_supp (notsupp : ¬¨P.supported) : P.degenerate :=
  by simp_all [Finprob.degenerate, Finprob.supported]

def shrink (supp : P.supported) : Finprob :=
  {‚Ñô := P.‚Ñô.shrink, prob := P.prob.shrink supp}


-- Define an induction principle for probability spaces
-- similar to the induction on lists, but also must argue about probability distributions

theorem nonempty : ¬¨P.‚Ñô.isEmpty :=
  by intro a;
     simp_all only [LSimplex.nonempty P.prob, List.isEmpty_iff]

theorem length_gt_zero : P.length ‚â• 1 :=
    by simp [Finprob.length]
       exact List.nonempty_length_gt_one (P.nonempty)

theorem shrink_length (supp : P.supported) : (P.shrink supp).length = P.length - 1 :=
    by  have h := Finprob.nonempty P
        simp [List.isEmpty] at h
        simp! [Finprob.shrink, Finprob.length, List.shrink, LSimplex.shrink]

theorem shrink_length_lt (supp : P.supported) : (P.shrink supp).length < P.length :=
    by rw [Finprob.shrink_length P supp]
       exact Nat.sub_one_lt_of_lt (Finprob.length_gt_zero P)

theorem nonempty_P : P.‚Ñô ‚â† [] := P.prob.nonempty

@[simp]
def phead := P.‚Ñô.head P.nonempty_P

@[simp]
def œâhead := P.length - 1

theorem phead_inpr : P.phead ‚àà P.‚Ñô := List.head_mem P.nonempty_P

theorem phead_prob : Prob P.phead :=
  P.prob.mem_prob P.phead P.phead_inpr

theorem phead_supp_ne_one (supp : P.supported) : P.phead ‚â† 1 :=
        by simp [Finprob.supported, LSimplex.supported, LSimplex.degenerate, LSimplex.phead] at supp
           simp [Finprob.phead]
           exact supp

theorem len_ge_one : P.length ‚â• 1 :=
  by simp [Finprob.length]
     have h := P.prob.nonempty
     have : P.‚Ñô.length ‚â† 0 := by simp_all only [ne_eq, List.length_eq_zero_iff, not_false_eq_true]
     exact Nat.one_le_iff_ne_zero.mpr this


theorem shrink_shorter (supp : P.supported) :
                                 (P.shrink supp).length = P.length - 1 :=
        by simp_all only [length, shrink, List.shrink_length, List.length_tail]

/-- Shows that growing an shrink probability will create the same probability space -/
theorem grow_of_shrink (supp : P.supported) : P = (P.shrink supp).grow P.phead_prob :=
    by rw [Finprob.mk.injEq] -- same fields equivalent to same structures
       simp [Finprob.shrink, Finprob.grow]
       apply LSimplex.grow_of_shrink_list
       simp_all only [decide_not, Bool.decide_eq_true, Bool.not_eq_eq_eq_not, Bool.not_true,
                Bool.false_eq_true, decide_false, Bool.not_false]
       exact P.prob


/-- induction principle for finite probabilities. Works as "induction P" -/
@[induction_eliminator]
def induction {motive : Finprob ‚Üí Prop}
        (degenerate :  {fp : Finprob} ‚Üí (d : fp.degenerate) ‚Üí motive fp)
        (composite : (tail : Finprob) ‚Üí  {p : ‚Ñö} ‚Üí (inP : Prob p) ‚Üí
                     (motive tail) ‚Üí motive (tail.grow inP))
        (P : Finprob) : motive P :=
    if b1 : P.‚Ñô = [] then
      by have := LSimplex.nonempty P.prob; simp_all
    else
      if b2 : P.degenerate then
        degenerate b2
      else
        let indhyp := Finprob.induction  degenerate composite (P.shrink (P.not_degen_supp b2))
        (Finprob.grow_of_shrink P (P.not_degen_supp b2)) ‚ñ∏
          composite (P.shrink (P.not_degen_supp b2)) P.phead_prob indhyp
    termination_by P.length
    decreasing_by
      simp only [length, shrink, gt_iff_lt]
      exact Finprob.shrink_length_lt P (P.not_degen_supp b2)

end Finprob

------------------------------ Section Finrv -----------------------------------
section RandomVariable

/-- Random variable defined on a finite probability space (bijection to ‚Ñï) -/

def FinRV (œÅ : Type) := ‚Ñï ‚Üí œÅ


namespace FinRV
@[simp]
def and (B : FinRV Bool) (C : FinRV Bool) : FinRV Bool :=
    fun œâ ‚Ü¶ B œâ && C œâ

infix:35 " ‚àß·µ£ " => FinRV.and

@[simp]
def or (B : FinRV Bool) (C : FinRV Bool) : FinRV Bool :=
    fun œâ ‚Ü¶ B œâ || C œâ

infix:30 " ‚à®·µ£ " => FinRV.or

@[simp]
def not (B : FinRV Bool) : FinRV Bool :=
  fun œâ ‚Ü¶ (B œâ).not

prefix:40 "¬¨·µ£" => FinRV.not


@[simp]
def eq {Œ∑ : Type} [DecidableEq Œ∑] (Y : FinRV Œ∑) (y : Œ∑) : FinRV Bool :=
  (fun œâ ‚Ü¶ decide (Y œâ = y) )

infix:50 "=·µ£" => FinRV.eq

@[simp]
def leq {Œ∑ : Type} [LE Œ∑] [DecidableLE Œ∑] (Y : FinRV Œ∑) (y : Œ∑) : FinRV Bool :=
  (fun œâ ‚Ü¶ Y œâ ‚â§ y)

infix:50 "‚â§·µ£" => FinRV.leq

/-- Shows equivalence when extending the random variable to another element. -/
theorem le_of_le_eq (D : FinRV ‚Ñï) (n : ‚Ñï) : ((D ‚â§·µ£ n) ‚à®·µ£ (D =·µ£ n.succ)) = (D ‚â§·µ£ n.succ) := by
  funext x --extensionality principle for functions
  unfold FinRV.leq FinRV.eq FinRV.or
  grind only [cases Or]

end FinRV


------------------------------ Section Probability ---------------------------

section Probability

----- standard probability

/-- Probability of a random variable. Does not enforce normalization -/
def List.iprodb (‚Ñô : List ‚Ñö) (B : FinRV Bool) : ‚Ñö :=
    match ‚Ñô with
    | [] => 0
    | head :: tail =>  (B tail.length).rec 0 head + tail.iprodb B


variable (P : Finprob) (B : FinRV Bool) (C : FinRV Bool)


variable (L : List ‚Ñö)

theorem List.scale_innerprod  (x : ‚Ñö) : (L.scale x).iprodb B = x * (L.iprodb B) :=
  by induction L with
     | nil => simp_all [List.scale, List.iprodb]
     | cons head tail =>
            simp_all [List.iprodb, List.scale]
            cases B tail.length
            ¬∑ simp_all
            ¬∑ simp_all
              ring

theorem List.decompose_supp (h : L ‚â† []) (ne1 : L.head h ‚â† 1):
    L.iprodb B = (B (L.length - 1)).rec 0 (L.head h) + (1-L.head h) * (L.shrink.iprodb B)  :=
    by conv => lhs; unfold iprodb
       cases L with
       | nil => simp at h
       | cons head tail =>
        simp [List.shrink]
        have := tail.scale_innerprod B (1-head)‚Åª¬π
        simp_all
        have hnz : 1 - head ‚â† 0 :=
          by by_contra; have : head = 1 := by linarith;
             contradiction
        calc
          tail.iprodb B = 1 * tail.iprodb B := by ring
          _ = (1 - head) * (1 - head)‚Åª¬π * tail.iprodb B  :=
              by rw [Rat.mul_inv_cancel (1-head) hnz]
          _ = (1 - head) * ((1 - head)‚Åª¬π * tail.iprodb B ) := by ring

theorem List.iprod_eq_zero_of_zeros (hz : ‚àÄ p ‚àà L, p = 0) : L.iprodb B = 0 :=
  by induction L with
     | nil => simp [iprodb]
     | cons head tail => simp_all [iprodb]; cases B tail.length; simp; simp


theorem List.iprod_first_of_tail_zero  (hn : L ‚â† []) (hz : ‚àÄ p ‚àà L.tail, p = 0) :
   L.iprodb B = (B L.tail.length).rec 0 (L.head hn)  :=
   by unfold iprodb
      cases L
      ¬∑ contradiction
      ¬∑ simp; simp at hz; (expose_names; exact iprod_eq_zero_of_zeros B tail hz)

lemma List.iprodb_true_sum : L.iprodb (fun _ ‚Ü¶ true) = L.sum :=
    by induction L
       ¬∑ simp only  [iprodb, sum_nil]
       ¬∑ simp_all only [iprodb, sum_cons]


/-- Probability of B -/
def probability : ‚Ñö :=  P.‚Ñô.iprodb B

notation "‚Ñô[" B "//" P "]" => probability P B

/-- Conditional probability of B -/
def probability_cnd : ‚Ñö := ‚Ñô[ B ‚àß·µ£ C // P ] / ‚Ñô[ C // P ]

--- main decomposition properties

/-- If supported then can be decomposed to the immediate probability and the
remaining probability -/
theorem Finprob.decompose_supp (supp : P.supported) :
    ‚Ñô[ B // P ] = (B P.œâhead).rec 0 P.phead + (1-P.phead) * ‚Ñô[ B // P.shrink supp ] :=
      by simp [Finprob.phead, Finprob.shrink]
         exact P.‚Ñô.decompose_supp B P.nonempty_P (P.phead_supp_ne_one supp)

theorem Finprob.decompose_degen (degen : P.degenerate) : ‚Ñô[ B // P ] = (B P.œâhead).rec 0 P.phead  :=
  by have tz := P.prob.degenerate_tail_zero degen
     simp [probability, Finprob.œâhead]
     have almost := P.‚Ñô.iprod_first_of_tail_zero B P.nonempty_P tz
     rw [List.length_tail] at almost
     exact almost

--- basic properties

theorem Finprob.in_prob (P : Finprob) : Prob ‚Ñô[ B // P ] :=
    by have hip := P.phead_prob
       by_cases h : P.supported
       ¬∑ rw [P.decompose_supp B h]
         have ih := Finprob.in_prob (P.shrink h)
         simp only [Prob] at ‚ä¢ ih hip
         cases B P.œâhead
         ¬∑ simp only;
           constructor;
           . have prd_zero : 0 ‚â§ (1 - P.phead) * ‚Ñô[B//P.shrink h] := Rat.mul_nonneg P.phead_prob.of_complement.1 ih.1
             simp_all only [phead, probability, zero_add]
           ¬∑ have prd_one : (1 - P.phead) * ‚Ñô[B//P.shrink h] ‚â§ 1 := mul_le_one‚ÇÄ P.phead_prob.of_complement.2 ih.1 ih.2
             simp_all only [phead, probability, zero_add]
         ¬∑ simp only;
           constructor;
           ¬∑ calc
               0 ‚â§ ‚Ñô[B//P.shrink h] := ih.1
               _ ‚â§ P.phead * 1 + (1 - P.phead) * ‚Ñô[B//P.shrink h] := P.phead_prob.lower_bound_snd ih.2
               _ = P.phead  + (1 - P.phead) * ‚Ñô[B//P.shrink h] := by ring
           ¬∑ calc
               P.phead + (1 - P.phead) * ‚Ñô[B//P.shrink h] =
                P.phead * 1 + (1 - P.phead) * ‚Ñô[B//P.shrink h] := by ring
               _ ‚â§ 1 := P.phead_prob.upper_bound_fst ih.2
       ¬∑ rw [P.decompose_degen B (P.degen_of_not_supp h) ]
         cases B P.œâhead
         ¬∑ simp_all
         ¬∑ simp_all
    termination_by P.length
    decreasing_by exact shrink_length_lt P h

theorem Prob.ge_zero : ‚Ñô[ B // P ] ‚â• 0 := (P.in_prob B).left

theorem Prob.le_one : ‚Ñô[ B // P ] ‚â§ 1 := (P.in_prob B).right

theorem Prob.true_one : ‚Ñô[ fun _ ‚Ü¶ true // P] = 1 :=
    by simp only [probability]; rw [List.iprodb_true_sum]; exact P.prob.normalized

--- sums

theorem List.list_compl_sums_to_one (L : List ‚Ñö) : L.iprodb B + L.iprodb (B.not) = L.sum :=
  by induction L with
     | nil => simp [List.iprodb]
     | cons head tail =>
        simp [List.iprodb]
        cases (B tail.length)
        ¬∑ simp; linarith
        ¬∑ simp; linarith


theorem List.law_of_total_probs (L : List ‚Ñö)  : L.iprodb B = L.iprodb (B ‚àß·µ£ C) + L.iprodb (B ‚àß·µ£ (¬¨·µ£C) ) :=
    by induction L with
       | nil => simp [List.iprodb]
       | cons head tail =>
          simp [List.iprodb]
          cases bB: B tail.length
          ¬∑ cases bC : C tail.length; simp_all; simp_all
          ¬∑ cases bC : C tail.length
            ¬∑ simp_all; ring;
            ¬∑ simp_all; ring;

theorem Prob.prob_compl_sums_to_one : ‚Ñô[B // P] + ‚Ñô[¬¨·µ£B // P] = 1 :=
  calc
    ‚Ñô[ B // P ] + ‚Ñô[ ¬¨·µ£B // P] = P.‚Ñô.sum := P.‚Ñô.list_compl_sums_to_one B
    _ = 1 := P.prob.normalized

theorem Prob.prob_compl_one_minus : ‚Ñô[¬¨·µ£B // P] = 1 - ‚Ñô[B // P] :=
    by have := Prob.prob_compl_sums_to_one P B
       linarith


theorem Prob.law_of_total_probs : ‚Ñô[B // P] = ‚Ñô[ B ‚àß·µ£ C // P] + ‚Ñô[ B ‚àß·µ£ ¬¨·µ£C //P] := P.‚Ñô.law_of_total_probs B C

---- conditional probability

notation "‚Ñô[" B "|" C "//" P "]" => probability_cnd P B C

theorem Prob.conditional_total (h : 0 < ‚Ñô[C // P]) : ‚Ñô[B ‚àß·µ£ C // P] =  ‚Ñô[ B | C // P] * ‚Ñô[ C // P] :=
  by simp [probability_cnd] at ‚ä¢ h
     have : P.‚Ñô.iprodb C * (P.‚Ñô.iprodb C)‚Åª¬π = 1 := Rat.mul_inv_cancel (P.‚Ñô.iprodb C) (Ne.symm (ne_of_lt h))
     calc
        P.‚Ñô.iprodb (B ‚àß·µ£C) = P.‚Ñô.iprodb (B ‚àß·µ£C) * 1 := by ring
        _ = P.‚Ñô.iprodb (B ‚àß·µ£C) * (P.‚Ñô.iprodb C * (P.‚Ñô.iprodb C)‚Åª¬π) := by rw [‚Üêthis]
        _ = P.‚Ñô.iprodb (B ‚àß·µ£ C) / P.‚Ñô.iprodb C * P.‚Ñô.iprodb C := by ring


theorem Prob.law_of_total_probs_cnd
  (h1 : 0 < ‚Ñô[C // P]) (h2 : ‚Ñô[C // P] < 1)  : ‚Ñô[B // P] = ‚Ñô[B | C // P] * ‚Ñô[ C // P] + ‚Ñô[B | ¬¨·µ£C //P] * ‚Ñô[¬¨·µ£C // P] :=
        by have h2' : 0 < ‚Ñô[¬¨·µ£C // P] := by rw [prob_compl_one_minus]; linarith
           rw [‚ÜêProb.conditional_total P B C h1]
           rw [‚ÜêProb.conditional_total P B (¬¨·µ£C) h2']
           exact law_of_total_probs P B C

end Probability

section Expectations

def List.iprod (‚Ñô : List ‚Ñö) (X : FinRV ‚Ñö) : ‚Ñö :=
    match ‚Ñô with
    | [] => 0
    | head :: tail =>  head * (X tail.length) + tail.iprod X


variable (P : Finprob) (X Y Z: FinRV ‚Ñö) (B : FinRV Bool)

def expect : ‚Ñö := P.‚Ñô.iprod X

notation "ùîº[" X "//" P "]" => expect P X

-- expectation for a joint probability space and random variable
notation "ùîº[" PX "]" => expect PX.1 PX.2



-- conditional expectation

def expect_cnd : ‚Ñö := P.‚Ñô.iprod X / P.‚Ñô.iprodb B

notation "ùîº[" X "|" B "//" P "]" => expect_cnd P X B

-- expectation for a joint probability space and random variable
notation "ùîº[" PX "]" => expect PX.1 PX.2
notation "ùîº[" PX "|" B "]" => expect_cnd PX.1 PX.2 B

-- conditional expectation: conditioning on a random variable: this defintion creates a probability
-- space and a random variable

variable {K : ‚Ñï} (D : FinRV (Fin K.succ))  -- a discrete random variable with K+1 values

end Expectations



-- The section defines measurabilty of random variables
section Measurability

/-- Represents the *generator* of the sample space of a Finprob. Each element
is mapped to a single generator. Note that different Finsample definitions
may induce equivalent sample spaces. Also there is no guarantee
that there will not be a generator with zero probability. -/
def Finprob.SampleMap (P : Finprob) (m : ‚Ñï) : Type := Fin P.length ‚Üí Fin m

variable {œÅ : Type} {P : Finprob} {m : ‚Ñï}

instance : CoeOut (Finprob.SampleMap P m) (FinRV (Fin m)) where coe a :=
           (fun œâ ‚Ü¶ if h : œâ < P.length then a ‚ü®œâ, h‚ü© else a ‚ü®0,P.len_ge_one‚ü©)

/-- Defines that the random variable X is measurable with respect to a map
and a reduced random variable Y
--/
def FinRV.MeasurableRV (X Y : FinRV œÅ) (‚Ñ± : P.SampleMap m) : Prop := ‚àÄ œâ : Fin P.length, X œâ = Y (‚Ñ± œâ)

/-- Defines the aggregated probability in the compacted space --/
def FinProb.MeasurableProb {L : List ‚Ñö} (‚Ñ± : P.SampleMap L.length) : Prop :=
    ‚àÄ m : Fin L.length, ‚Ñô[‚Ñ± =·µ£ m // P] = L.get m


--example {m : ‚Ñï} {‚Ñ± : P.SampleMap m} (h: X.Measurable Y ‚Ñ±) : 1 = ùîº[ X // P ] := by sorry
end Measurability
